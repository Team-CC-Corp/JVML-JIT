local args = {...}

local usage = "Usage: jvml [-d] <mainclass>"
local mainClass
local javaArgs = {}

local switches = {
    debug=false,
    time=false
}
local switchShortcuts = {
    d="debug",
    t="time"
}

while args[1] do
    local arg = table.remove(args, 1)
    if arg:sub(1,1) == "-" then
        -- arg is an option
        local success = true
        local switch = arg:sub(2)
        if switches[switch] ~= nil then
            switches[switch] = true
        else
            for c in switch:gmatch(".") do
                if switchShortcuts[c] then
                    switches[switchShortcuts[c]] = true
                else
                    success = false
                end
            end
        end
        if not success then
            print("Unknown argument: ", arg)
            print(usage)
            return
        end
    else
        -- arg is the main class
        mainClass = arg
        for v in function() return table.remove(args, 1) end do
            -- rest of args goes into javaArgs
            table.insert(javaArgs, v)
        end
    end
end

if not mainClass then
    print(usage)
    return
end

local jcd = fs.combine("", shell.getRunningProgram():sub(1, -1 - #(fs.getName(shell.getRunningProgram()))))

local env = setmetatable({
    jcd = jcd,
    jcp = "/" .. fs.combine(jcd, "CCLib/build/classes")..":."
}, {__index=getfenv()})

env.debugMode = switches.debug
if switches.debug then
    local handle = fs.open(fs.combine(jcd, 'debug'), 'w')
    env.debugH = handle
else
    env.debugH = {write=function() end, flush=function() end, close=function() end}
end

local nloadfile = loadfile
local function dofile(path, ...)
    local f = assert(nloadfile(path))
    setfenv(f, env)
    return f(...)
end

function env.loadfile(path)
    local h = fs.open(path, "r")
    local f, err = loadstring(h.readAll(), fs.getName(path))
    h.close()
    setfenv(f, env)
    return f, err
end

do -- load LAT with jvml as virtually the root
    local f = assert(nloadfile(fs.combine(env.jcd, "lasm/LAT.lua")))
    setfenv(f, setmetatable({
        loadfile=function(path)
            return env.loadfile(fs.combine(env.jcd, path))
        end
    }, {
        __index=env,
        __newindex=env
    }))
    f()
end
dofile(fs.combine(env.jcd, "jvml_data/vm/classpath.lua"))
dofile(fs.combine(env.jcd, "jvml_data/vm/jit.lua"))
dofile(fs.combine(env.jcd, "jvml_data/vm/classloader.lua"))
dofile(fs.combine(env.jcd, "jvml_data/vm/arrays.lua"))

env.jcp = env.jcp .. ":/" .. env.jcd -- So that loadJavaClass isn't needed here

-- Make java arguments array
local jArray = env.newArray(env.getArrayClass("[Ljava.lang.String;"), #javaArgs)
for i,v in ipairs(javaArgs) do
    jArray[5][i] = env.toJString(v)
end
local m = env.findMethod(env.classByName(mainClass), "main([Ljava/lang/String;)V")[1]

-- Begin
local startTime
if switches.time then
    startTime = os.time()
end

local ok, err = pcall(m, jArray)
if not ok then
    printError(err)
    env.printStackTrace(true)
end
if switches.time then
    local endTime = os.time()
    print("\nTime: ", endTime - startTime)
end
env.debugH.close()