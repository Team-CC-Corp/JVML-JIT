local args = {...}

local usage = "Usage: jvml [-d] <mainclass>"
local mainClass
local debugMode = false
for i = 1, #args do
    local arg = args[i]
    if arg == "-d" then
        debugMode = true
    elseif arg:sub(1, 1) == "-" then
        print(usage)
        return
    elseif not mainClass then
        mainClass = arg
    else
        print(usage)
        return
    end
end

if not mainClass then
    print(usage)
    return
end

local jcd = fs.combine("", shell.getRunningProgram():sub(1, -1 - #(fs.getName(shell.getRunningProgram()))))

local env = setmetatable({
    jcd = jcd,
    jcp = "/" .. fs.combine(jcd, "CCLib/build/classes")..":."
}, {__index=getfenv()})

env.debugMode = debugMode

local nloadfile = loadfile
local function dofile(path, ...)
    local f = assert(nloadfile(path))
    setfenv(f, env)
    return f(...)
end

function env.loadfile(path)
    local h = fs.open(path, "r")
    local f, err = loadstring(h.readAll(), fs.getName(path))
    h.close()
    setfenv(f, env)
    return f, err
end

do -- load LAT with jvml as virtually the root
    local f = assert(nloadfile(fs.combine(env.jcd, "lasm/LAT.lua")))
    setfenv(f, setmetatable({
        loadfile=function(path)
            return env.loadfile(fs.combine(env.jcd, path))
        end
    }, {
        __index=env,
        __newindex=env
    }))
    f()
end
dofile(fs.combine(env.jcd, "jvml_data/vm/classpath.lua"))
dofile(fs.combine(env.jcd, "jvml_data/vm/classloader.lua"))

env.jcp = env.jcp .. ":/" .. env.jcd -- So that loadJavaClass isn't needed here
local m = env.findMethod(env.classByName(mainClass), "main([Ljava/lang/String;)V")[1]
for i = 1, #env.staticMethods do
    local m = env.staticMethods[i]
    local ok, err = pcall(m)
    if not ok then
        printError(err)
        env.printStackTrace(true)
        return
    end
end

local ok, err = pcall(m)
if not ok then
    printError(err)
    env.printStackTrace(true)
end
